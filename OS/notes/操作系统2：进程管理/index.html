<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="澹台千儿" href="http://tantaiqianer.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="澹台千儿" href="http://tantaiqianer.github.io/atom.xml"><link rel="alternate" type="application/json" title="澹台千儿" href="http://tantaiqianer.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://tantaiqianer.github.io/OS/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"><title>操作系统 (2)：进程管理 - 操作系统 - 计算机 | Tantai Qianer = 澹台千儿</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?58bf9ed12e0698075dbd6500fec2ae08";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><meta name="generator" content="Hexo 6.0.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">操作系统 (2)：进程管理</h1><div class="meta"><span class="item" title="创建时间：2022-06-11 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-06-11T00:00:00+08:00">2022-06-11</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>5.9k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>5 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Tantai Qianer</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tantaiqianer.github.io/images/Shoka/6833939bly1giclhtuo6nj20zk0m8ttm.jpg"></li><li class="item" data-background-image="https://tantaiqianer.github.io/images/Shoka/6833939bly1gicm0fdw5cj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tantaiqianer.github.io/images/Shoka/6833939bly1giciuja1j1j20zk0m8kjl.jpg"></li><li class="item" data-background-image="https://tantaiqianer.github.io/images/Shoka/6833939bly1giclfdu6exj20zk0m87hw.jpg"></li><li class="item" data-background-image="https://tantaiqianer.github.io/images/Shoka/9ca8d4e098a5e62fe53df1752e08454d3461568723422067.jpg"></li><li class="item" data-background-image="https://tantaiqianer.github.io/images/Shoka/6833939bly1gicliwyw55j20zk0m8hdt.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="item" rel="index" title="分类于 计算机"><span itemprop="name">计算机</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="item" rel="index" title="分类于 操作系统"><span itemprop="name">操作系统</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://tantaiqianer.github.io/OS/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="澹台千儿"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="澹台千儿"></span><div class="body md" itemprop="articleBody"><h1 id="进程"><a class="anchor" href="#进程">#</a> 进程</h1><h2 id="进程的基本概念"><a class="anchor" href="#进程的基本概念">#</a> 进程的基本概念</h2><p><span class="pink">进程</span> (process) 是进行中的程序的抽象。其设计是为了实现多个程序的并发执行，进而实现操作系统的<strong>并发</strong>和<strong>共享</strong>两个最基本的特征。</p><h2 id="进程的组成"><a class="anchor" href="#进程的组成">#</a> 进程的组成</h2><p>进程包括以下几个主要的部分：</p><ul><li><span class="pink">代码段</span>：保存进程需要执行的程序。</li><li><span class="pink">数据段</span>：保存程序中全局变量的值。</li><li><span class="pink">代码库</span>：进程执行所依赖的共享的代码库。</li><li><span class="pink">用户栈</span>：保存各种临时变量的值。值得注意的是，栈的扩展方向是<strong>自顶向下</strong>的，即栈底固定在高地址不动，当栈开销变大时，栈顶向低地址方向移动。</li><li><span class="pink">用户堆</span>：管理进程动态分配的内存，与栈相反，堆的扩展方向是<strong>自底向上</strong>，即堆顶位于高地址，堆开销变大时，堆顶向高地址移动。</li><li><span class="pink">内核部分</span>：位于进程中地址空间的最顶端，包括内核中需要使用的代码和数据，以及内核内存等。进程控制块就位于这一部分。</li></ul><h3 id="进程控制块"><a class="anchor" href="#进程控制块">#</a> 进程控制块</h3><p>为保证并发执行的每个程序都能独立运行，需要为进程配备独立的数据结构，称为<span class="pink">进程控制块</span> (Process Control Block, <strong>PCB</strong>)。系统利用 PCB 实现对进程的控制和管理，PCB 也是进程存在的<strong>唯一标志</strong>。操作系统内的每个进程的相关信息，采用 PCB 进行存储。具体包括以下方面:</p><ul><li><strong>进程状态</strong> (process state)</li><li><strong>进程标识符</strong> (process identification, <strong>PID</strong>) 和<strong>用户标识符</strong> (user identification, <strong>UID</strong>)</li><li><strong>程序计数器</strong> (program counter, <strong>PC</strong>): 存放现行指令的地址。</li><li><strong>CPU 寄存器</strong> (CPU register): 包括 CPU 的各种寄存器，如累加器、索引寄存器、堆栈指针等。其实程序计数器也可以归入其中。</li><li><strong>CPU 调度信息</strong> (CPU-scheduling information): 包括<strong>进程优先级</strong>、调度队列的指针等参数。</li><li><strong>内存管理信息</strong> (memory-management information): 根据操作系统的内存系统确定，包括基地址和页表、段表等。</li><li><strong>记账信息</strong> (accounting information): 包括 CPU 使用时间、作业或进程数量等。</li><li><strong>I/O 状态信息</strong> (I/O status information): 这类信息包括分配给进程的 I/O 设备列表、打开文件列表等。</li></ul><h3 id="上下文"><a class="anchor" href="#上下文">#</a> 上下文</h3><p>进程的<span class="pink">上下文</span> (context) 是用来跟踪进程的相关信息的数据结构，属于 PCB. 其包括的信息为进程运行时的寄存器状态，其能够用于保存和恢复一个进程在处理器上运行的状态。当进程中断后，其对应的寄存器内容等运行环境将被保存到内存中，当进程需要恢复运行时，操作系统调用内存中的内容恢复进程的运行环境。这样的技术称为<span class="pink">上下文切换</span> (context switch)。上下文切换的流程如下：</p><ol><li>挂起一个进程，保存 CPU 上下文，包括程序计数器和其他寄存器。</li><li>更新 PCB 信息。</li><li>把进程的 PCB 移入相应的队列，如就绪、在某事件上阻塞队列。</li><li>选择另一个进程执行，并更新其 PCB.</li><li>跳转到新进程的 PCB 中的程序计数器所指向的位置执行。</li><li>恢复处理器上下文。</li></ol><h2 id="进程的状态"><a class="anchor" href="#进程的状态">#</a> 进程的状态</h2><p>进程的全部状态包括:</p><ul><li><span class="pink">新建</span> (new): 表示一个进程刚刚被创建，但是还未进行初始化，不能被执行的状态。</li><li><span class="pink">就绪</span> (或<span class="pink">预备</span>，ready): 进程已经准备好运行，但由于某些原因未开始运行的状态。</li><li><span class="pink">执行</span> (running): 正在处理器上执行指令的状态。</li><li><span class="pink">阻塞</span> (blocked): 阻塞状态下，进程执行了某操作后，会等待某外部事件发生后再运行，即处于中断状态。例如程序发起 I/O 请求后会阻塞，直至 I/O 请求得到响应后退出阻塞状态继续运行。</li><li><span class="pink">终止</span> (terminated): 表示进程已经完成了执行，且不会被再次调度。</li></ul><p>关于进程间各状态的转换，可以参考下图:</p><p><img data-src="../../../images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1.png" alt="Fig1: 进程的各状态转换图"></p><div class="note warning"><p>值得注意的是，进程可以从执行态转变为就绪态，只要进程的时间片达到或有更高优先级的进程抢占其资源。此外，在进程的所有状态转换中，只有<strong>执行态</strong>到<strong>阻塞态</strong>的转换是进程自身决定的。</p></div><h2 id="进程api的设计"><a class="anchor" href="#进程api的设计">#</a> 进程 API 的设计</h2><p>为运行进程，操作系统必须提供一定的进程 API，主要包括以下几个方面:</p><ul><li><strong>创建</strong> (create): 创建新进程的方法。进程的创建是一个原语，称为<strong>创建原语</strong>。在 Linux 中采用 <code>folk</code> 接口实现进程的创建。</li><li><strong>销毁</strong> (destroy): 强制销毁进程的方法。进程的销毁是一个原语，称为<strong>终止原语</strong>，在 Linux 中采用 <code>exit</code> 或 <code>abort</code> 实现。</li><li><strong>等待</strong> (wait): 等待进程停止运行的方法。在 Linux 中采用 <code>wait</code> 接口实现。</li><li><strong>杂项控制</strong> (miscellaneous): 对进程的其他控制方法，例如暂停 (中断) 进程和恢复进程，分别对应<strong>阻塞原语</strong>和<strong>唤醒原语</strong>。</li><li><strong>状态</strong> (status): 用于获取进程状态的方法。</li></ul><h3 id="进程的创建"><a class="anchor" href="#进程的创建">#</a> 进程的创建</h3><p>进程的创建过程分为以下几个步骤：</p><ol><li>为新进程分配一个唯一的进程标识号，并申请一个空白 PCB. 若 PCB 申请失败，则创建失败。</li><li>建立虚拟运行环境，包括为进程分配内存等资源、为进程创建线程和分配设备等。</li><li>初始化 PCB, 主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。</li></ol><h2 id="进程间通信"><a class="anchor" href="#进程间通信">#</a> 进程间通信</h2><p><span class="pink">进程间通信</span> (Inter-Process Communication, <strong>IPC</strong>) 是多进程协作的基础。其目标是通过操作系统共享进程间的数据资源，实现应用程序互联。进程的通信一般包括<span class="pink">共享内存</span>、<span class="pink">消息传输</span>和<span class="pink">管道通信</span>三种方式。</p><div class="note warning"><p>共享内存中可能出现争用问题，这时需要借助信号量解决。</p></div><h1 id="线程"><a class="anchor" href="#线程">#</a> 线程</h1><h2 id="线程的基本概念"><a class="anchor" href="#线程的基本概念">#</a> 线程的基本概念</h2><p><span class="pink">线程</span> (thread) 是程序执行流的最小单元，是比进程更轻量的运行时抽象。也可以说，线程是程序在虚拟 CPU 上的执行过程，或执行中的程序。</p><p>仅采用进程存在一些局限。例如：</p><ol><li>进程的开销较大 (<strong>资源问题</strong>)</li><li>进程的隔离性过强 (<strong>独立性问题</strong>)</li><li>进程内部不能实现并行 (<strong>并发性问题</strong>)</li></ol><p>于是，我们将进程细分出更小的结构 —— 线程。引入线程后，上述的三个问题可以得到解决。在资源问题上，进程是系统拥有资源的基本单位，而线程除自身必须的少量出资源外不占有系统资源。因此线程的开销较小。尽管线程不占有系统资源，但线程可以访问其所隶属的进程的系统资源，这就使得同一进程下的不同线程可以实现方便的资源共享。当引入线程后，程序执行的最小单位变为线程，因而可以实现线程调度，使得同一进程内部的不同线程可以实现并行。</p><h2 id="线程控制块"><a class="anchor" href="#线程控制块">#</a> 线程控制块</h2><p><span class="pink">线程控制块</span> (Thread Control Block, <strong>TCB</strong>) 是操作系统描述和管理线程的数据结构。其通常包括以下几部分：</p><ul><li>线程标识符</li><li>一组寄存器，包括程序计数器、状态寄存器和通用寄存器；</li><li>线程运行状态，用于描述线程处于何种状态</li><li>优先级</li><li>线程专有存储区，在线程切换时保存现场</li><li>堆栈指针，用于过程调用时保存局部变量及返回地址等</li></ul><h2 id="线程的实现方式"><a class="anchor" href="#线程的实现方式">#</a> 线程的实现方式</h2><p>线程的实现方式可以分为和<strong>用户级线程</strong>和<strong>内核级线程</strong>。此外，也可以在两种方式的基础上进行组合。</p><h3 id="用户级线程"><a class="anchor" href="#用户级线程">#</a> 用户级线程</h3><p><span class="pink">用户级线程</span> (user-level thread, <strong>ULT</strong>) 是指线程管理工作都由应用程序在用户空间内完成的线程。因此，即使将程序划分为多个用户级线程，内核也不能意识到多线程的存在。</p><p>其优点如下：</p><ol><li>线程切换不需要转换到内核空间，节省了模式转换的开销。</li><li>线程内调度算法是专用的，不同进程可以根据自身需要，选择不同的调度算法。</li><li>用户级线程的实现和操作系统平台无关，对线程管理的代码是用户程序的一部分。</li></ol><p>其缺点如下：</p><ol><li>当进程执行系统调用而被阻塞时，整个进程内的所有线程都被阻塞。</li><li>不能发挥多处理机的优势，进程中每次只能有一个线程执行。</li></ol><h3 id="内核级线程"><a class="anchor" href="#内核级线程">#</a> 内核级线程</h3><p><span class="pink">内核级线程</span> (kernel-level thread, <strong>KLT</strong>) 是指线程管理工作都在内核空间内实现的线程。</p><p>其优点如下：</p><ol><li>能发挥多处理机的优势，同一程序的多个线程可以并行执行。若进程中的一个线程被阻塞，其余线程仍然可以执行。</li><li>内核支持线程具有很小的数据结构和堆栈，线程切换比较快、开销小。</li><li>内核本身也可以采用多线程技术，提高系统的执行速度和效率。</li></ol><p>其缺点如下：<br>同一进程中的线程切换，需要从用户态转到内核态进行，系统开销较大。</p><h3 id="多线程模型"><a class="anchor" href="#多线程模型">#</a> 多线程模型</h3><p><img data-src="../../../images/OS/thread01.png" alt="多线程模型"></p><h1 id="cpu调度"><a class="anchor" href="#cpu调度">#</a> CPU 调度</h1><h2 id="调度基础"><a class="anchor" href="#调度基础">#</a> 调度基础</h2><h3 id="调度的概念"><a class="anchor" href="#调度的概念">#</a> 调度的概念</h3><p><span class="pink">调度</span> (scheduling) 是操作系统实现资源分配的方式。</p><h3 id="调度的分类"><a class="anchor" href="#调度的分类">#</a> 调度的分类</h3><p>调度可以按照层次分类。对于一项作业，其往往要经历三级调度：</p><ol><li><strong>高级调度</strong> (<strong>作业调度</strong>)：即从外存上处于后备队列中的作业中选取并建立相应进程的调度，其本质是<strong>内存和外存的调度</strong>，对于每个作业，只调入一次，调出一次。后面介绍的磁盘调度即为此层次的调度。</li><li><strong>中级调度</strong> (<strong>内存调度</strong>)：是在内存中进行的调度，其目的是提高<ins class="wavy">内存利用率</ins>和<ins class="wavy">系统吞吐量</ins>，一种主要的方式为将暂不运行的进程调至外存 (即<strong>挂起</strong>)。</li><li><strong>低级调度</strong> (<strong>进程调度</strong>)：是最基本、频率最高的调度，即按照某种方式将 CPU 分配给进程。</li></ol><p>此外，调度还可以按是否发生抢占分类为<span class="pink">抢占式调度</span> (preemptive scheduling) 和<span class="pink">非抢占式调度</span> (nonpreemptive scheduling)。</p><h3 id="调度的衡量指标"><a class="anchor" href="#调度的衡量指标">#</a> 调度的衡量指标</h3><p>调度算法可以采用一些指标来衡量。以进程调度 (CPU 调度) 为例，其主要包括以下衡量指标：</p><ol><li><strong>CPU 利用率</strong>：定义为 CPU 有效工作时间与 CPU 工作总时间的比值。其中 CPU 工作总时间是 CPU 有效工作时间和 CPU 空闲等待时间的和。</li><li><strong>吞吐量</strong>：定义为单位时间内 CPU 完成作业的数量。</li><li><strong>等待时间</strong>：即所有线程在就绪队列中等待的时间之和。</li><li><strong>响应时间</strong>：定义为用户从提交请求到系统首次响应所耗费的时间。</li><li><strong>周转时间</strong>：定义为从作业提交到作业完成所经历的时间。对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 个线程，其周转时间各自为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>, 则常采用<strong>平均周转时间</strong></li></ol><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi>T</mi><mo>ˉ</mo></mover><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\bar{T} = \frac{1}{n}\sum_{i=1}^nT_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8201099999999999em;vertical-align:0"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8201099999999999em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span></span></span><span style="top:-3.25233em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-.16666em"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.686em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em"><span style="top:-1.872331em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em"><span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></span></p><p>来衡量。此外，如果还知道线程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 的实际执行时间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.07153em">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.07153em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>, 则还可以用<strong>平均带权周转时间</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><msub><mi>T</mi><mi>i</mi></msub><msub><mi>C</mi><mi>i</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{n}\sum_{i=1}^n\frac{T_i}{C_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.686em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em"><span style="top:-1.872331em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em"><span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em"><span style="top:-2.3139999999999996em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.07153em">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.07153em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.8360000000000001em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>来衡量。</p><p>对于其余层次的调度，也可以将对象类比后得到近似的衡量指标。</p><h2 id="调度器"><a class="anchor" href="#调度器">#</a> 调度器</h2><p><span class="pink">调度器</span> (scheduler) 即<span class="pink">调度程序</span>，是 CPU 调度的软件基础。其通常包括下面三部分：</p><ol><li>排队器</li><li>分派器</li><li>上下文切换器</li></ol><p>其结构如下图：</p><p><img data-src="../../../images/OS/scheduler01.png" alt="调度器的结构"></p><h2 id="调度算法"><a class="anchor" href="#调度算法">#</a> 调度算法</h2><h3 id="先来先服务fcfs"><a class="anchor" href="#先来先服务fcfs">#</a> 先来先服务 (FCFS)</h3><h3 id="短作业优先sjf"><a class="anchor" href="#短作业优先sjf">#</a> 短作业优先 (SJF)</h3><h3 id="优先级调度priority"><a class="anchor" href="#优先级调度priority">#</a> 优先级调度 (priority)</h3><ul><li>时间片轮转调度 (RR):</li><li>多级队列调度</li><li>多级反馈队列调度:</li></ul><h1 id="同步与互斥"><a class="anchor" href="#同步与互斥">#</a> 同步与互斥</h1><h2 id="基本概念"><a class="anchor" href="#基本概念">#</a> 基本概念</h2><h3 id="临界资源"><a class="anchor" href="#临界资源">#</a> 临界资源</h3><p>不能被并发使用的资源称为<span class="pink">临界资源</span> (critical resource)。</p><p>临界资源的访问一般分为四个部分：</p><ol><li><span class="pink">进入区</span> (entry section)：为了进入临界区使用临界资源，在进入区要检查可否进入临界区，若能进入临<br>界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。</li><li><span class="pink">临界区</span> (critical section)：进程中访问临界资源的那段代码，又称临界段。</li><li><span class="pink">退出区</span> (exit section)：将正在访问临界区的标志清除。</li><li><span class="pink">剩余区</span> (remainder section)：代码中的其余部分。</li></ol><p>为禁止两个进程同时进入临界区，临界区访问应遵循以下准则：</p><ul><li><strong>空闲让进</strong>：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li><li><strong>忙则等待</strong>：当已有进程进入临界区时，其他试图进入临界区的进程必须等待。</li><li><strong>有限等待</strong>：对请求访问的进程，应保证能在有限时间内进入临界区。</li><li><strong>让权等待</strong>：当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</li></ul><h3 id="同步"><a class="anchor" href="#同步">#</a> 同步</h3><p>并发执行环境下，保持操作之间<strong>偏序关系</strong>的行为，称为<span class="pink">同步</span> (synchronization)，又称直接制约关系。</p><h3 id="互斥"><a class="anchor" href="#互斥">#</a> 互斥</h3><p>并发执行环境下，两进程<strong>不能同时使用临界区资源</strong>的约束称为<span class="pink">互斥</span> (mutual exclusion, mutex)，又称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。</p><h2 id="同步机制的实现方法"><a class="anchor" href="#同步机制的实现方法">#</a> 同步机制的实现方法</h2><h3 id="基于硬件的方法"><a class="anchor" href="#基于硬件的方法">#</a> 基于硬件的方法</h3><p>对于单处理器，一般采用中断屏蔽的方式实现。</p><h3 id="基于软件的方案"><a class="anchor" href="#基于软件的方案">#</a> 基于软件的方案</h3><p><strong>Peterson 方法</strong>是最经典的互斥机制的软件方案之一。在该方法中， <code>turn</code> 变量表示当前进入临界区的进程， <code>flag</code> 表示当前进程是否希望进入临界区。代码如下：</p><p>设置公共变量 <code>int turn = 0; Boolean flag[2];</code></p><p>对进程 0，其代码结构为：</p><figure class="highlight cpp"><figcaption data-lang="C++"><span>进程0</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">do</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> T<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// critical section</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> F<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// reminder section</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>对进程 1，其代码结构为：</p><figure class="highlight cpp"><figcaption data-lang="C++"><span>进程0</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">do</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> T<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// critical section</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> F<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// reminder section</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><div class="note warning"><p>由于现代计算机的基本指令有差别，不能确保 Peterson 方法仍能正确运行在这类机器上。</p></div><h2 id="锁"><a class="anchor" href="#锁">#</a> 锁</h2><p><span class="pink">锁</span> (lock) 是操作系统设计人员基于软件方法解决临界区问题而设计的应用程序。从操作系统的角度来看，由于</p><h3 id="基本操作"><a class="anchor" href="#基本操作">#</a> 基本操作</h3><p>锁的基本操作包括<strong>获取</strong> (acquire) 和<strong>释放</strong> (release) 两种。</p><figure class="highlight cpp"><figcaption data-lang="C++"><span>lock</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>available<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    available <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    available <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="互斥锁"><a class="anchor" href="#互斥锁">#</a> 互斥锁</h3><p><span class="pink">互斥锁</span> (mutex lock) 是最基本的锁工具。</p><h3 id="自旋锁"><a class="anchor" href="#自旋锁">#</a> 自旋锁</h3><h2 id="信号量"><a class="anchor" href="#信号量">#</a> 信号量</h2><h1 id="死锁"><a class="anchor" href="#死锁">#</a> 死锁</h1><h2 id="死锁的概念"><a class="anchor" href="#死锁的概念">#</a> 死锁的概念</h2><p><span class="pink">死锁</span> (deadlock) 是指在多道程序环境中，多单线程进程间相互竞争资源，导致任一进程所申请的资源都被其余等待进程占有，使得无外力情况下各进程均一直处于阻塞态无法运行的情形。</p><h2 id="死锁产生的必要条件"><a class="anchor" href="#死锁产生的必要条件">#</a> 死锁产生的必要条件</h2><p>死锁的产生有四个必要条件，这些条件也被称为<span class="pink">死锁的特征</span> (<span class="pink">deadlock characterization</span>)。</p><ol><li><strong>互斥</strong>：请求资源的多个进程存在互斥。</li><li><strong>保持等待</strong> (<strong>请求并保持</strong>)：进程在等待时保持已占用的资源，等待获得申请的资源。</li><li><strong>非抢占</strong> (<strong>不剥夺</strong>)：进程不能抢占其它进程的资源。</li><li><strong>循环等待</strong>：各进程形成一条或多条进程间等待的环路。</li></ol><h2 id="死锁处理策略"><a class="anchor" href="#死锁处理策略">#</a> 死锁处理策略</h2><h3 id="死锁的避免"><a class="anchor" href="#死锁的避免">#</a> 死锁的避免</h3><p>破坏死锁产生的上述四个必要条件之一即可实现死锁的避免。</p><ol><li>破坏<strong>保持等待</strong>条件，方法是采用<strong>预先静态分配</strong>的方式分配资源，缺点是会产生资源的严重浪费。</li><li>破坏<strong>循环等待</strong>条件：方法是采用<strong>顺序资源分配</strong>的方式分配资源，进程必须按照编号递增的顺序申请资源，且同类资源只能一次申请完。缺点是资源编号必须相对稳定，就限制了新类型设备的增加。此外，也可能造成一定程度的资源浪费。</li></ol><h1 id="reference"><a class="anchor" href="#reference">#</a> Reference</h1><ul><li>GeekForGeeks<ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvbXV0ZXgtdnMtc2VtYXBob3JlLw==">Mutex vs Semaphore</span></li><li></li></ul></li></ul></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-10-07 09:10:18" itemprop="dateModified" datetime="2024-10-07T09:10:18+08:00">2024-10-07</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>澹台千儿 <i class="ic i-at"><em>@</em></i>澹台千儿</li><li class="link"><strong>本文链接：</strong> <a href="http://tantaiqianer.github.io/OS/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" title="操作系统 (2)：进程管理">http://tantaiqianer.github.io/OS/notes/操作系统2：进程管理/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/OS/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1%EF%BC%9A%E6%A6%82%E5%BF%B5%E5%92%8C%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tantaiqianer.github.io&#x2F;images&#x2F;Shoka&#x2F;6833939bly1gipexw3o58j20zk0m8e81.jpg" title="操作系统(1)：概念和前置知识"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 操作系统</span><h3>操作系统(1)：概念和前置知识</h3></a></div><div class="item right"><a href="/TCS/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA(2)/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tantaiqianer.github.io&#x2F;images&#x2F;Shoka&#x2F;6833939bly1gipevgoki5j20zk0m84qp.jpg" title="上下文无关文法与下推自动机"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 计算理论</span><h3>上下文无关文法与下推自动机</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">进程的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.2.</span> <span class="toc-text">进程的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">1.2.1.</span> <span class="toc-text">进程控制块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.2.2.</span> <span class="toc-text">上下文</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.</span> <span class="toc-text">进程的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8Bapi%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.</span> <span class="toc-text">进程 API 的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.4.1.</span> <span class="toc-text">进程的创建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">1.5.</span> <span class="toc-text">进程间通信</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">线程的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">2.2.</span> <span class="toc-text">线程控制块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">线程的实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">用户级线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text">内核级线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.3.3.</span> <span class="toc-text">多线程模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cpu%E8%B0%83%E5%BA%A6"><span class="toc-number">3.</span> <span class="toc-text">CPU 调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%9F%BA%E7%A1%80"><span class="toc-number">3.1.</span> <span class="toc-text">调度基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.1.</span> <span class="toc-text">调度的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.1.2.</span> <span class="toc-text">调度的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E8%A1%A1%E9%87%8F%E6%8C%87%E6%A0%87"><span class="toc-number">3.1.3.</span> <span class="toc-text">调度的衡量指标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">调度器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1fcfs"><span class="toc-number">3.3.1.</span> <span class="toc-text">先来先服务 (FCFS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88sjf"><span class="toc-number">3.3.2.</span> <span class="toc-text">短作业优先 (SJF)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6priority"><span class="toc-number">3.3.3.</span> <span class="toc-text">优先级调度 (priority)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="toc-number">4.</span> <span class="toc-text">同步与互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"><span class="toc-number">4.1.1.</span> <span class="toc-text">临界资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-number">4.1.2.</span> <span class="toc-text">同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5"><span class="toc-number">4.1.3.</span> <span class="toc-text">互斥</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">同步机制的实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%A1%AC%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">基于硬件的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">4.2.2.</span> <span class="toc-text">基于软件的方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">4.3.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.1.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">4.3.2.</span> <span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">4.3.3.</span> <span class="toc-text">自旋锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">4.4.</span> <span class="toc-text">信号量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">死锁的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.2.</span> <span class="toc-text">死锁产生的必要条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">5.3.</span> <span class="toc-text">死锁处理策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%81%BF%E5%85%8D"><span class="toc-number">5.3.1.</span> <span class="toc-text">死锁的避免</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#reference"><span class="toc-number">6.</span> <span class="toc-text">Reference</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/OS/CSAPP/CSAPP%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/" rel="bookmark" title="CSAPP学习指南">CSAPP学习指南</a></li><li><a href="/OS/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1%EF%BC%9A%E6%A6%82%E5%BF%B5%E5%92%8C%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/" rel="bookmark" title="操作系统(1)：概念和前置知识">操作系统(1)：概念和前置知识</a></li><li class="active"><a href="/OS/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" rel="bookmark" title="操作系统(2)：进程管理">操作系统(2)：进程管理</a></li><li><a href="/OS/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="bookmark" title="操作系统(3)：内存管理">操作系统(3)：内存管理</a></li><li><a href="/OS/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" rel="bookmark" title="操作系统(4)：文件系统">操作系统(4)：文件系统</a></li><li><a href="/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/" rel="bookmark" title="操作系统概念总结">操作系统概念总结</a></li><li><a href="/OS/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F5%EF%BC%9A%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/" rel="bookmark" title="操作系统(5)：设备管理">操作系统(5)：设备管理</a></li><li><a href="/OS/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" rel="bookmark" title="Linux系统调用">Linux系统调用</a></li><li><a href="/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/" rel="bookmark" title="操作系统课设总结">操作系统课设总结</a></li><li><a href="/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" rel="bookmark" title="操作系统实验报告">操作系统实验报告</a></li><li><a href="/OS/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B3%BB%E7%BB%9F/" rel="bookmark" title="运行时系统">运行时系统</a></li><li><a href="/OS/CSAPP/CSAPP1%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" rel="bookmark" title="CSAPP(1)：计算机系统概述">CSAPP(1)：计算机系统概述</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="澹台千儿" data-src="/images/avatar.jpg"><p class="name" itemprop="name">澹台千儿</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">376</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">96</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">5</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9saXUtbGlhbmctMzItOTQ=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;liu-liang-32-94"><i class="ic i-zhihu"></i></span> <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RhbnRhaVFpYW5lcg==" title="https:&#x2F;&#x2F;github.com&#x2F;TantaiQianer"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/OS/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1%EF%BC%9A%E6%A6%82%E5%BF%B5%E5%92%8C%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/TCS/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA(2)/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/computer-graphics/Games101%E9%9A%8F%E8%AE%B0/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%A4%BE%E4%BC%9A%E5%AD%A6/" title="分类于 社会学">社会学</a></div><span><a href="/sociology/sociology-notes/" title="社会学读书随记">社会学读书随记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%83%B3%E6%B3%95/" title="分类于 想法">想法</a></div><span><a href="/ideas-and-diary/230316shoka/" title="shoka 修复计划">shoka 修复计划</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="分类于 计算机">计算机</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/machine-learning/" title="分类于 机器学习">机器学习</a></div><span><a href="/machine-learning/NeuralNetworkPotentials/" title="神经网络势函数">神经网络势函数</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="分类于 计算机">计算机</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" title="分类于 图形学">图形学</a></div><span><a href="/computer-graphics/OpenGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="OpenGL 学习记录">OpenGL 学习记录</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%83%B3%E6%B3%95/" title="分类于 想法">想法</a></div><span><a href="/ideas-and-diary/241113%E5%A6%82%E4%BD%95%E5%81%9A%E5%87%BA%E4%B8%80%E9%A1%B9%E5%A5%BD%E7%9A%84%E7%A0%94%E7%A9%B6/" title="如何做出一项好的研究">如何做出一项好的研究</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="分类于 计算机">计算机</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%B7%A5%E7%A8%8B%E9%97%AE%E9%A2%98/" title="分类于 工程问题">工程问题</a></div><span><a href="/engineering-prob/Python%20%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83/" title="Python 注释规范">Python 注释规范</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%95%B0%E5%AD%A6/" title="分类于 数学">数学</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA/" title="分类于 概率论">概率论</a></div><span><a href="/mathematics/%E6%A6%82%E7%8E%87%E8%AE%BA/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AC%94%E8%AE%B04%EF%BC%9A%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/" title="概率论笔记(4)：大数定律与中心极限定理">概率论笔记(4)：大数定律与中心极限定理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="分类于 计算机">计算机</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%8F%AF%E8%A7%86%E5%8C%96/" title="分类于 可视化">可视化</a></div><span><a href="/visualization/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="可视化期末复习">可视化期末复习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="分类于 计算机">计算机</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 算法与数据结构">算法与数据结构</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E7%AE%97%E6%B3%95/" title="分类于 图算法">图算法</a></div><span><a href="/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/graph-alg/1%20%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/" title="图的存储">图的存储</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">澹台千儿 @ Tantai Qianer</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">802k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">12:09</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"OS/notes/操作系统2：进程管理/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>